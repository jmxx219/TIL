# 7. 데이터 암호화

(이부분 사실 잘 이해가 안간다...)

### 목차

- [7.1 MySQL 서버의 데이터 암호화](#71-mysql-서버의-데이터-암호화)
- [7.2 keyring_file 플러그인 설치](#72-keyring_file-플러그인-설치)
- [7.3 테이블 암호화](#73-테이블-암호화)
- [7.4 언두 로그 및 리두 로그 암호화](#74-언두-로그-및-리두-로그-암호화)
- [7.5 바이너리 로그 암호화](#75-바이너리-로그-암호화)


<br>

> MySQL 5.7 버전부터 암호화 기능이 지원되기 시작했고, 처음에는 데이터 파일(테이블스페이스)에 대해서만 암호화 기능이 제공됐다. 이후 MySOL 8.0으로 업그레이드되면서 데이터 파일뿐만 아니라 리두 로그나 언두 로그, 복제를 위한 바이너리 로그 등도 모두 암호화 기능을 지원하기 시작했다.  
> 응용 프로그램의 암호화는 주로 중요 정보를 가진 **칼럼 단위**로 암호화를 수행하며, 데이터베이스 수준에서는 **테이블 단위**로 암호화를 적용한다.

## 7.1 MySQL 서버의 데이터 암호화

- 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서 암호화 또는 복호화를 수행한다.
  - 그래서 MySQL 서버에서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요치 않다.
  - 즉, MySQL 서버(InnoDB 스토리지 엔진)의 I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행된다.
- 테이블의 데이터가 암호화되어 있는지 여부를 식별할 필요가 없으며, 암호화된 테이블도 그렇지 않은 테이블과 동일한 처리 과정을 거친다.
  - MySQL 내부와 사용자 입장에서는 아무런 차이가 없다.
  - 이러한 암호화 방식을 `TDE(Transparent Data Encryption)`라고 한다.

<br>

### 7.1.1 2 단계 키 관리

- TDE에서 암호화 키는 키링(KeyRing) 플러그인에 의해 관리된다.
- 다양한 키링 관리 플러그인이 존재하지만 모두 마스터 키를 관리하는 방법만 다르고 내부적으로 작동하는 방식은 동일하다.
- MySQL 서버의 키링 플러그인은 `2단계(2-Tier) 키 관리 방식`을 사용한다.

#### 2단계(2-Tier) 키 관리 방식
- MySQL 서버에서는 `마스터 키(master key)`와 `테이블스페이스 키(tablespace key)` 라는 두 가지 키로 암호화를 한다.
  - 2단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서다.
  - 테이블스페이스 키가 변경되면 모든 데이터를 다시 복호화했다가 암호화해야 하는데, 이는 엄청난 작업이고 성능에 큰 영향을 준다.
- 암호화 과정
  1. 디스크의 keyring_file에서 마스터 키를 가져온다.
  2. 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급한다. 
  3. 마스터 키를 이용해서 테이블스페이스 키를 암호화해서 각 테이블의 데이터파일 헤더에 저장한다.
     - 이렇게 생성된 테이블 스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다.
- 마스터 키 변경(`ALTER INSTANCE ROTATE INNODB MASTER KEY;`)
  - 테이블스페이스 키는 절대 MySQL의 서버 외부로 노출되지 않기 때문에 주기적으로 변경하지 않아도 보안상 취약점이 되지 않는다.
  - 하지만 마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있어 주기적으로 변경해야 한다.
  
#### 암호화 알고리즘
- MySQL TDE에서 지원되는 암호화 알고리즘은 AES 256비트이며, 이외의 알고리즘은 지원되지 않는다.
- 테이블스페이스 키는 AES-256 ECB(Electronic CodeBook) 알고리즘을 이용해 암호화되고, 제 데이터 파일은 AES-256 CBC(Cipher Block Chaining) 알고리즘을 이용해 암호화된다.


<br>

### 7.1.2 암호화와 성능

- MySQL 서버의 암호화 방식은 TDE 방식이기 때문에 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재된다.
  - 그래서 데이터페이지가 한 번 메모리에 적재하면 암호화되지 않은 테이블과 동일한 성능을 보인다.
  - 하지만 InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽는 경우, 복호화하는 시간이 더 걸린다.
  - 또한 암호화된 테이블이 변경되는 경우, 디스크로 동기화할 때 암호화하는 시간이 추가로 더 걸린다.
- AES 암호화 알고리즘은 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다.
  - 즉, 암호화한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않는다.
- 암호화와 압축이 동시에 적용되면, MySQL 서버는 압축을 먼저 실행하고 암호화를 한다.
  - 암호화된 결과문은 아주 랜덤한 바이트 배열을 가지게 되는데, 이는 압축률을 상당히 떨어뜨린다.
  - 따라서 최대한 압축 효율을 노이기 위해 사용자 데이터 그대로 압축해서 용량을 최소화한 후에 암호화를 적용한다.
- 암호화된 테이블의 경우 읽기는 3~5배, 쓰기는 5~6배정도로 느리고, 밀리초 단위이기 때문에 크게 체감되지 않을 수 있다.

<br>

### 7.1.3 암호화와 복제

(이해를 못했다..)

<br>


## 7.2 keyring_file 플러그인 설치

> MySQL 서버의 데이터 암호화 기능인 `TDE`의 암호화 키 관리는 플러그인 방식으로 제공된다.  
> MySQL 커뮤니티 에디션에서는 `keyring_file` 플러그인만 가능하다.

- keyring_file 플러그인은 테이블스페이스 키를 암호화하기 위해 마스터 키를 디스크 파일로 관리한다.
  - 이때 스터 키는 평문으로 디스크에 저장되기 때문에 마스터 키가 저장된 파일이 외부에 노출되면 데이터 암호화는 무용지물이 된다.
- TDE 플러그인은 MySQL 서버가 시작되는 단계에서 가장 빨리 초기화 되야 한다.
  - 따라서 설정 파일(my.cnf)에 다음을 명시하면 된다.
  ```sql
  -- //라이브러리 명시
  early-plugin-load = keyring_file.so
  -- //마스터 키를 저장할 키링 파일 경로 설정
  keyring_file_data = /very/secure/directory/tde_master.key
  ```
- keyring_file 플러그인이 초기화되면 MySQL 서버는 플러그인의 초기화와 동시에 keyring_file_data 시스템 변수의 경로에 빈 파일을 생성한다.
  - 아직 플러그인만 초기화 되어 있고, 데이터 암호화 기능을 사용하는 테이블을 생성하거나 마스터 로테이션을 실행하면 키링 파일의 마스터 키가 초기화된다.

<br>

## 7.3 테이블 암호화

> 키링 파일 플러그인은 마스터 키 생성까지만 담당하기 때문에 어떤 플러그인을 쓰더라도 테이블 암호화하는 방식은 동일하다.

### 7.3.1 테이블 생성

- 테이블 생성 구문 마지막에 `ENCRYPTION='Y'` 옵션만 추가로 넣으면 된다.
- 모든 테이블에 대해 암호화를 적용하고자 한다면 `default_table_encryption` 시스템 변수를 `ON`으로 설정하면 된다.

<br>

### 7.3.2 응용 프로그램 암호화와의 비교

- 응용 프로그램으로 암호화된 컬럼은 인덱스를 생성하더라도 그 기능을 100% 활용할 수 없다.
  - MySQL 서버는 칼럼의 값이 이미 암호화된 것인지 여부를 인지하지 못하기 때문이다.
- 응용 프로그램의 암호화와 MySQL 서버의 암호화 기능 중 선택해야 하는 상황이라면 MySQL 서버 암호화를 선택하는 것이 좋다.
  - 두 암호화는 목적과 용도가 조금 다르다.
  - MySQL 서버의 암호화는 MySQL에 로그인할 수 있다고 해도 평문의 내용을 확인할 수 있지만, 응용 프로그램 암호화는 확인할 수 없다.

<br>

### 7.3.3 테이블스페이스 이동

- 테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 `테이블스페이스 이동(Export & Import)` 기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠르다.
- 암호화된 테이블의 경우, 테이블스페이스 이동 기능을 사용할 때는 반드시 데이터 파일과 임시 마스터 키가 저장된 *.cfp 파일을 함께 복사해야 한다.

<br>

## 7.4 언두 로그 및 리두 로그 암호화

> MySQL 8.0.16 버전부터 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있게 개선됐다.

- MySQL 서버는 리두 로그나 언두 로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두 로그나 언두 로그만 암호화해서 저장한다.
- 리두 로그와 언두 로그는 각각의 전용 프라이빗 키가 발급되고, 해당 프라이빗 키는 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일의 헤더에 저장된다.

<br>

## 7.5 바이너리 로그 암호화

> 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고 , MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하지는 않는다.

### 7.5.1 바이너리 로그 암호화 키 관리

- 바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키(FIle Key)로 암호화해서 디스크로 저장하고, 파일 키는 `바이너리 로그 암호화 키`로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장된다.
  - `바이너리 로그 암호화 키`는 테이블 암호화의 마스터 키와 동일한 역할을 한다.
  - 파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동 생성되어 해당 로그 파일의 데이터 암호화에만 사용된다.

<br>

### 7.5.2 바이너리 로그 암호화 키 변경

```sql
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키) 로 암호화해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장(암호화되지 않은 로그 파일은 무시)
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

<br>

### 7.5.3 mysqlbinlog 도구 활용

- 바이너리 로그 암호화 키는 MySQL 서버만 가지고 있어서 바이너리 로그 파일을 외부에서 복호화가 불가능하다.
- 그나마 암호화된 바이너리 로그 파일의 내용을 볼 수 있는 방법은 MySQL 서버를 통해 가져오는 방법이 유일하다.
  - mysqlbinlog 명령을 실행할 때 `--read-from-remote-server` 파라미터와 함께 접속 정보를 입력한다.

<br>
<br>
