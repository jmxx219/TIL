# 4. 아키텍쳐

### 목차

- [4.1 MySQL 엔진 아키텍처](#41-mysql-엔진-아키텍처)
- [4.2 InnoDB 스토리지 엔진 아키텍처](#42-innodb-스토리지-엔진-아키텍처)
- [4.3 MyISAM 스토리지 엔진 아키텍처](#43-myisam-스토리지-엔진-아키텍처)
- [4.4 MySQL 로그 파일](#44-mysql-로그-파일)

<br>

## [4.1 MySQL 엔진 아키텍처](#목차)

### 4.1.1 MySQL의 전체 구조

> MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구성된다. MySQL 엔진은 사람의 머리 역할을 담당하고, 스토리지 엔진은 손과 발의 역할을 담당한다. MySQL 고유의 C API부터 시작해 JDBC나 ODBC, 그리고 .NET의 표준 드라이버를 제공하며, 이러한 드리아버를 통해 모든 언어로 MySQL 서버에서 쿼리를 사용할 수 있게 지원한다.  

<img width="400" src="https://github.com/user-attachments/assets/d1b7cd74-0815-4a16-bb19-a85d013b3b99">

- `MySQL 엔진`
  - SQL을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
  - 커넥션 핸들러(클라이언트로부터의 접속 및 쿼리 요청을 처리), SQL 파서, 전처리기, 옵타마이저(쿼리의 최적화된 실행), 캐시 & 버퍼 등등이 중심을 이룬다.
- `스토리지 엔진`
  - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 등 MySQL의 손발 역할을 전담한다.
  - MySQL 엔진은 하나지만, 이와 다르게 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
  - 테이블이 사용할 스토리지 엔진을 지정하면, 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 스토리지 엔진이 수행한다.
    ```sql
    CREATE TABLE test(fd1 INT, fd2 INT) ENGINE=INNODB; # 테이블이 사용할 스토리지 엔진을 지정
    ```
  - MySQL 엔진의 핸들러 API를 통해 호출되며, 대표적으로 `InnoDB`, `MyIsam`, `Memory` 등 스토리지 엔진이 존재한다.
- `핸들러 API`
  - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진으로 쓰기 또는 읽기를 요청하는데, 이를 핸들러 요청이라고 한다.
      - 여기서 사용되는 API를 `핸들러 API`라고 한다.
  - InnoDB 스토리지 엔진도 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다.

<br>

### 4.1.2 MySQL 스레딩 구조

> MySQL 서버는 프로세스 기반이 아니라 **스레드 기반**으로 동작하며, 크게 `포그라운드 스레드`와 `백그라운드 스레드`로 구분할 수 있다. 
> MySQL 서버에서 실행 중인 스레드의 목록은 `performance_schema` 데이터베이스의 `threads` 테이블을 통해 확인할 수 있다.

<img src="https://velog.velcdn.com/images/dragonappear/post/736dfe0f-90ab-4750-a558-598e3582a331/image.png" width="400"/>

- `포그라운드 스레드(클라이언트 스레드)`
  - 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
  - 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시(Thread Cache)로 되돌아간다.
      - 이 때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면, 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.
  - 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시에서 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
      - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
      - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 작업(디스크 기록 등)은 백그라운드 스레드가 처리한다.
- `백그라운드 스레드`
  - MyISA의 경우에는 해당 사항이 별로 없지만, InnoDB는 여러 작업이 백그라운드로 처리된다.
    - 로그를 디스크로 기록하는 스레드, InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 등등이 있다.
  - 사용자의 요청을 처리하는 도중 데이터 쓰기 작업은 지연되어 처리될 수 있지만, 읽기 작업은 절대 지연될 수 없다.
  - 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 또한 이러한 방식으로 처리한다.
      - 이러한 이유로 InnoDB에서는 쓰기 쿼리로 데이터가 변경되는 경우, 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
      - MyISAM은 그렇지 않고 사용자 쓰레드가 쓰기 작업까지 함께 처리하도록 설계되어 있다.

<br>

### 4.1.3 메모리 할당 및 사용 구조

> MySQL에서 사용 되는 메모리 공간은 크게 `글로벌 메모리 영역`과 `로컬 메모리 영역`으로 구분 할 수 있다. MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.  
> - 대표적인 글로벌 메모리 영역: 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnODB 리두 로그 버퍼  
> - 대표적인 로컬 메모리 영역: 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼  

<img src="https://github.com/user-attachments/assets/2dab3d6f-c5da-4eab-8ac9-22bbe23c72be" width="400"/>

- `글로벌 메모리 영역`
  - 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
      - 실제로는 엄청 복잡하지만, 단순하게 MySQL 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각하면 된다.
  - 클라이언트 스레드의 수와 무관하게 **하나의 메모리 공간**만 할당된다.
      - 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트 스레드 수와는 무관하다.
      - 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 공유된다.
- `로컬 메모리 영역(세션 메모리 영역)`
  - MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
      - 클라이언트 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하는데, 클라이언트 스레드가 사용하는 메모리 공간이라고해서 클라이언트 메모리 영역이라고도 한다.
      - 또한, MySQL 서버와의 커넥션을 섹션이라고도 하기 때문에 세션 메모리 영역이라고도 표현한다.
  - 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며, 절대 공유되어 사용되지 않는다.
  - 각 쿼리마다 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다.
    - ex) 소트 버퍼, 조인 버퍼
  - 커넥션이 열려있는 동안 계속 할당된 상태로 남아있는 공간(커넥션 버퍼, 결과 버퍼)도 있으며, 그렇지 않고 쿼리를 실행하는 순간만 할당했다가 다시 해제하는 공간(소트 버퍼, 조인 버퍼)도 있다.

<br>

### 4.1.4 플러그인 스토리지 엔진 모델

> MySQL의 독특한 구조 중 대표적인 것이 플러그인 모델이다.

MySQL은 기본적으로 많은 스토리지 엔진을 가지고 있다.
- 하지만 수많은 사용자의 요구 조건을 만족시키기 위해 기본적으로 제공되는 스토리지 엔진 외에 부가적인 기능을 더 제공하는 스토리지 엔진을 필요할 수 있다. 그래서 직접 스토리지 엔진을 개발하여 플러그인 형태로 제공할 수 있다. 
- 따라서 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워 넣기만 하면 손쉽게 부가적인 기능도 사용할 수 있게 된다.
- 또한 플러그인 형태의 스토리지 엔진은 손쉽게 업그레이드할 수 있다.

MySQL 서버에서는 스토리지 엔진뿐만 아니라 다양한 기능을 플러그인 형태로 지원한다.
- 인증이나 전문 검색 파서 또는 쿼리 재작성과 같은 플러그인이 있으며, 비밀번호 검증과 커넥션 제어 등에 관련된 다양한 플러그인이 제공된다.
- 이뿐만 아니라 MySQL 서버에서 제공하는 기능들을 커스텀하여 확장하거나 완전히 새로운 기능들을 플러그인을 이용해 구현할 수도 있다.

<br>

#### MySQL에서 쿼리가 실행되는 과정

<img src="https://github.com/user-attachments/assets/af329a0f-cf2c-4bb4-a4ce-079f189a2e14" width="500"/>

- `SQL 파서`, `SQL 옵티마이저`, `SQL 실행기`까지의 작업은 SQL 엔진의 영역에서 처리되며, `데이터 읽기/쓰기`의 작업만 스토리지 엔진 모델에서 처리된다.
- 즉 사용자가 새로운 스토리지 엔진을 만든다고 하더라도 데이터 DBMS의 전체 기능이 아닌 일부분의 기능만 수행하는 엔진을 만들게 된다. 
  - 즉 MyISAM을 사용하나 InnoDB를 사용하나 `데이터 읽기/쓰기` 영역에서의 처리만 차이가 있을 뿐이다.
  - 실질적인 GROUP BY, ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MysQL 엔진의 처리 영역인 `쿼리 실행기` 에서 처리된다.

<br>

### 4.1.5 컴포넌트

> MySQL. 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.

플러그인 단점
- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

MySQL 5.7 버전까지는 비밀번호 검증 기능이 플러그인 형태로 제공됐지만 MySQL 8.0의 비밀번호 검증 기능은 컴포넌트로 개선되었다.
```sql
-- validate_password 컴포넌트 설치
mysal> INSTALL COMPONENT 'file://component_validate_password';

-- 설치된 컴포넌트 확인
mysql> SELECT * FROM mysql. component;
```

<br>

### 4.1.6 쿼리 실행 구조

> 쿼리를 실행하는 관점에서 MySQL 구조를 기능별로 나눌 수 있다.

<img width="400" src="https://github.com/user-attachments/assets/3c40582f-c05b-4635-90e5-d352e0fe4152">

- `쿼리 파서`
  - SQL 요청을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)로 분리해 트리 형태의 구조로 만들어내는 작업을 수행한다
  - 쿼리의 문법 오류는 이 과정에서 발견되고, 오류가 있을 경우 사용자에게 오류 메시지를 전달하게 된다.
- `전처리기`
  - 이전의 파서 과정에서 만들어진 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
  - 이후 토큰을 테이블 이름, 컬럼 이름 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체 접근 권한을 확인하는 과정을 수행한다.
    - 실제로 존재하지 않거나 권한 상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.
- `옵티마이저`
  - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리 할지를 결정하는 역할과 실행계획을 작성을 담당하며, DBMS의 두뇌에 해당한다.
- `실행 엔진(쿼리 실행기)`
  - 옵티마이저가 계획한대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 손발 역할을 수행한다.
  - 실행 엔진은 만들어진 실행 계획대로 각 핸들러에게 요청을 하게 되고, 또 다시 받은 결과를 또 다른 핸들러를 요청하여 입력으로 연결하는 역할을 한다.
- `핸들러(스토리지 엔진)`
  - MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.
  - 핸들러는 결국 스토리지 엔진을 의미하며, InnoDB의 테이블일 경우 핸들러는 InnoDB 스토리지 엔진이 된다.

<br>

### 4.1.7 복제

> MysOL 서버에서 복제 (Replication) 는 매우 중요한 역할을 담당한다. [16장 복제]()에서 살펴본다.

<br>

### 4.1.8 쿼리 캐시

MySQL 서버에서 쿼리 캐시(Query Cache)는 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당했다.
- SOL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능을 보였다.
- 하지만 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제 해야 했고, 이는 심각한 동시 처리 성능 저하를 유발한다.

결국 MySOL 8.0으로 올라오면서 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거되었다.
- 쿼리 캐시 기능은 아주 독특한 환경(데이터 변경은 거의 없고 읽기만 하는 서비스) 에서는 매우 훌륭한 기능이지만, 이러한 요건을 가진 서비스가 흔치 않다.

<br>

### 4.1.9 스레드 풀

> `MysOL 서버 엔터프라이즈 에디션`은 스레드 풀(Thread Pool) 기능을 제공하지만 `MySQL 커뮤니티 에디션`은 스레드 풀 기능을 지원하지 않는다.
> 여기서는 Percona Server에서 제공하는 스레드 풀 기능을 살펴보고자 한다.

스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많아도 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버 자원 소모를 줄이는 것이 목적이다.
- 하지만 스레드 풀이 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드물다.
- 또한, 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하면 쿼리 처리가 더 느려지는 사례도 발생할 수 있다.
- CPU가 제한된 수의 스레드로 처리하게 적절히 유도한다면 CPU의 프로세서 친화도를 높이고 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있다.

<details>
<summary>추가 내용</summary>
<div markdown="1">
<br>

Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성한다. 
- 스레드 그룹 개수를 thread_pool_size로 조정할 수 있다.
- 일반적으로는 스레드 그룹 개수를 CPU 코어의 개수와 맞추는 것이 좋다.

MySQL 서버가 처리해야할 요청이 생기면 스레드 풀로 처리를 이관한다.
- 이 때 이미 스레드 풀에 처리 중안 작업이 있는 경우 thread_pool_oversubscribe 시스템 변수에 설정된 개수만큼 추가로 더 받아들여서 처리한다.
    - thread_pool_oversubscribe: 한개의 스레드 그룹 안에서 몇개의 스레드까지 동시에 active 상태일 수 있게할 것인지
    - 이 값이 너무 클 경우 스케줄링 해야할 스레드가 많아져 스레드 풀이 비효율적으로 작동할 수도 있다.

스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 스레드 그룹에 새로운 작업 스레드를 추가할지 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단한다.
- 스레드 풀의 타이머 스레드는 주기적으로 스레드 그룹의 상태를 체크해서 thread_pool_stall_limit 시스템 변수에 정의된 시간만큼 작업스레드가 처리중인 작업을 완료못하면 새로운 스레드를 스레드 그룹에 추가한다.
    - 이 때 전체 스레드의 개수는 thread_pool_max_threads를 넘을 수 없다.
- 즉, 모든 스레드 그룹의 스레드가 각자 작업을 처리하는 동안 새로운 요청이 들어와도 스레드는 thread_pool_stall_limit 만큼 기다려야 새로운 요청을 처리할 수 있다
- 따라서 응답 시간에 아주 민감한 서비스라면 thread_pool_stall_limit 시스템 변수를 적절히 낮춰서 설정해야 한다.

Percona Server의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다.
- 이렇게 먼저 시작된 트랜잭션을 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 나춰서 전체적인 처리 성능을 향상시킨다.

<br>
</div>
</details>


> MySQL 엔터프라이즈 스레드 풀 기능은 MySQL 서버 프로그램에 내장돼 있지만, Percona Server의 스레드 풀은 플러그인 형태로 작동하게 구현돼 있다는 차이점이 있다.
> MySQL 커뮤니티 에디션에서도 스레드 풀 기능을 사용하고자 한다면 동일 버전의 Percona Server에서 스레드 풀 플러그인 라이브러를 설치해서 사용할 수 있다.

<br>

### 4.1.10 트랜잭션 지원 메타데이터

MySQL 서버 5.7 버전까지 테이블 구조를 파일 기반으로 관리했다.
- 하지만 이러한 파일 기반의 메타데이터는 생성 및 변경 작업에 트랜잭션을 지원하지 않기 때문에 테이블 생성이나 변경 도중 MySQL 서버가 비정상 종료가 되면 일관성이 보장되지 않아 DB나 테이블이 깨지는 현상이 발생했다.

따라서 MySQL 8.0부터는 테이블 구조 정보나 스토어드 프로그램의 코드 관련 정보 등의 정보를 모두 InnoDB의 테이블에 저장하도록 개선하였다.
- 이제 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 완전한 성공 또는 완전한 실패로 정리된다.

- MysOL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블은 메타 정보가 InnoDB 테이블 기반의 딕셔너리에 저장되지만, MyISAM 이나 CSV 등과 같은 스토리지 엔진의 메타 정보는 여전히 저장할 공간이 필요하다.
  - 따라서 MySOL 서버는 InnoDB 스토리지 엔진 이외의 스토리지 엔진을 사용하는 테이블들을 위해 SDI(Serialized Dictionary Information) 파일을 사용한다.

<br>
<br>

## [4.2 InnoDB 스토리지 엔진 아키텍처](#목차)

> MySQL 서버에서는 InnoDB 스토리지 엔진을 기본 스토리지 엔진으로 사용한다.  
> InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

<img width="350" src="https://github.com/user-attachments/assets/016b80a6-fff6-4a63-9670-8e27d4fab0aa">

<br>

### 4.2.1 프라이머리 키에 의한 클러스터링

> 클러스터링 인덱스: 테이블 전체가 정렬된 인덱스가 되는 방식(테이블 레코드들이, 인덱스 컬럼의 정렬 순서대로 적재되어 있는 것)  
> 세컨더리 인덱스: 클러스터형 인덱스와 다르게 물리적으로 테이블을 정렬하지 않는다. 정렬된 별도의 인덱스 페이지를 생성하고 관리한다.

기본적으로 InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다.
- 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- PK가 클러스터링 인덱스이기 때문에 PK를 통한 Range 스캔이 매우 빠르게 처리될 수 있다.
  - 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.

MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.
- MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.
- 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.
- MyISAM 테이블의 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 가진다.

<br>

### 4.2.2 외래 키 지원

InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로, MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.
- 따라서 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발 시에 외래 키의 존재에 주의하는 것이 좋다.

<br>

### 4.2.3 MVCC(Multi Version Concurrency Control)

> 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나로, `Multi Version`은 하나의 레코드에 대해서 여러 개의 버전을 동시에 관리한다는 의미한다.

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 지원하는 기능이다.
- MVCC는 잠금(Locking)을 사용하지 않으면서 일관된 값을 읽도록 만드는 것이 목적이다.
  - InnoDB 스토리지 엔진은 트랜잭션의 격리 수준을 위해 잠금을 사용하지 않고 읽기 작업을 수행한다.
  - 즉, 잠금을 사용하지 않고 하나의 레코드에 대해 여러 개의 버전이 동시에 관리될 수 있다는 것을 의미한다.
- InnoDB의 경우 `언두 로그`를 활용하여 이 기능을 구현한다.

<br>

<img width="350" src="https://github.com/user-attachments/assets/6c395257-a6cb-4ca7-aac2-77f4ad5e7959">

- 아직 커밋이나 롤백이 되지 않은 상태에서 같은 쿼리로 작업 중인 레코드를 조회하면 결과는 격리 수준에 따라 다르다.
    - `READ_UNCOMMITTED`: InnoDB 버퍼 풀이 현재 가지고 있는 최신 버전의 데이터를 읽어서 반환한다.
        - 즉, 커밋됐든 아니든 변경된 상태의 데이터를 반환한다.
    - `READ_COMMITTED`나 그 이상의 격리 수준(`REPEATABLE_READ`, `SERIALIZABLE`)인 경우: 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신, 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.
        - Undo 로그에 저장된 레코드 값으로 레코드를 조회하면 굳이 레코드의 Lock을 걸 필요 없이 일관된 읽기가 가능해진다.
- 이러한 과정을 DBMS에서는 `MVCC` 라고 표현한다.
    - 하나의 레코드에 대하 여러 개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조다.

UPDATE 쿼리가 실행되면 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되고 기존 데이터는 언두영역으로 복사된다.
- COMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.
- 하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해 버린다.
- 컷밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것이 아닌, 이 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.

<br>

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

MVCC 기술로 읽기작업은 다른 트랜잭션의 잠금에 대기하지 않고 바로 실행될 수 있다.
- SERIALIZABLE이 아닌 격리 수준(`READ_UNCOMMITTED`, `READ_UNCOMMITTED`, `REPEATABLE_READ`)일 때 INSERT와 연결되지 않은 순수한 읽기 작업(SELECT)은 다른 트랜잭션의 변경 작업에 관계없이 잠금 대기 없이 바로 실행된다.

오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 수 있다.
- 원인: 잠금 없는 일관된 읽기의 특성(`언두 로그를 지속적으로 유지`) 때문이다.
- 따라서 트랜잭션 시작 시, 롤백이나 커밋을 통해 가능한 한 빠르게 트랜잭션을 완료하는 것이 좋다.

<br>

### 4.2.5 자동 데드락 감지

> InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해, 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리함

#### 데드락 감지 시스템 (`innodb_deadlock_detect`)

데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그 중 하나를 강제 종료한다.
- 트랜잭션 강제 종료 판단 기준은 `트랜잭션의 언두 로그 양`이다.
  - 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.
  - 이유: 트랜잭션이 적은 언두 로그 레코드를 가졌다 → 롤백 시 언두처리할 내용 적다 → 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하 덜 유발한다.

동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다.
- 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업 진행을 못하고 대기하면서 서비스에 악영향 미친다.
- 이를 해결하기 위해 innodb_deadlock_detect를 OFF로 설정해서 비활성화하고 innodb_lock_wait_timeout을 활성화하여, 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 한다.

<br>

### 4.2.6 자동화된 장애 복구

> MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.

InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.
- 이 단계에서 자동으로 복구될 수 없는 손상 있을 경우 자동 복구 멈추고 MySQL 서버는 종료된다.
- 종료되었을 시, MySQL 서버의 설정 파일의 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 다시 시작해야 한다.

`innodb_force_recovery`: 1 ~ 6의 값을 가지며, 단계별로 선별적 자동복구를 진행할 수 있다.

<br>

### 4.2.7 InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 `캐시해 두는 공간`이자 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 `버퍼 역할`을 한다.
- 보통 데이터를 변경하는 쿼리는 파일의 여러에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시키지만, 버퍼 풀은 이러한 변경된 데이터를 모아서 처리하기 때문에 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

#### 버퍼 풀의 크기 설정
- 운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해서 설정해야 한다.
- MySQL 5.7 버전부터 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선됐다.
  - InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 방법이 최적이다.
  - InnoDB 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크기 때문에 이 작업은 하지 않도록 주의한다.
- 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인한 내부 잠금 경합이 많이 유발되었지만, 버퍼 풀을 여러 개로 쪼개어 관리할 수 있도록 개선되었다.

#### 버퍼 풀의 구조
- 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 필요할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 LRU, 플러시, 프리 리스트라는 3개의 자료구조를 이용한다.
  - Free 리스트: 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이다.
  - LRU 리스트: 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 **디스크 읽기를 최소화**하는 것이다.
  - Flush 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다.

#### 버퍼 풀과 리두 로그

- InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 `데이터 캐시`와 `쓰기 버퍼링`이라는 두 가지 용도가 있다.
  - 단순히 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상시키는 것이다.
  - 버퍼 풀의 쓰기 버퍼링 기능까지 향상하려면 버퍼 풀과 리두 로그와의 관계를 이해해야 한다.
- 버퍼풀은 클린 페이지와 더티 페이지를 가지며, 허용 가능한 더티 페이지의 크기가 쓰기 버퍼링의 성능과 관계가 있다.
  - 클린 페이지: 디스크에서 읽은 상태로 전혀 변경되지 않은, 원본 페이지
  - 더티 페이지: INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가지는 페이지
  - 리두 로그: 고정 크기 파일을 연결해서 순환 고리처럼 사용하여 리두 공간이 계속 재사용되지만, 기록될 때마다 고유 번호인 LSN은 계속 증가한다.
- 더티 페이지의 경우, 디스크와 데이터 상태가 다르기 때문에 언젠가 동기화가 필요하다. 
  - 버퍼 풀의 더티 페이지는 체크포인트 이벤트가 발생하면 체크포인트의 LSN 보다 작은 리두 로그 엔트리와 관련된 더티 페이지(변경 페이지)는 모두 디스크로 동기화한다.
  - 이처럼 메모리에서만 변경 작업이 일어나다가, 체크 포인트 이벤트 발생 시점에 한번에 디스크로 반영되므로 `쓰기 버퍼링`이라고 한다.
- 데이터베이스 성능을 최적화하고 싶다면 InnoDB 버퍼 풀과 리두 로그 파일의 전체 크기를 적절히 선택해 최적 값을 찾아야 한다.

#### 버퍼 풀 플러시 (Buffer Pool Flush)

- MySQL 5.6 버전 까지는 InnoDB 더티 페이지 플러시 기능이 부드럽게 처리 되지 않았다.
  - MySQL 8.0 부터는 대부분의 서비스에서는 더티 페이지를 디스크에 동기화 부분에서 예전과 같은 디스크 쓰기 폭증 현상 문제가 발생하지 않았다.
  - InnoDB는 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다.
- 플러시 리스트 플러시
  - InnoDB는 리두 로그 공간에서 오래된 더티 페이지들을 동기화하고 비워둔다.
  - 주기적으로 플러시 리스트(Flush_list) 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다.
- LRU 리스트 플러시
  - InnoDB는 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어둔다.
  - InnoDB가 LRU 끝부분부터 스캔하여 더티 페이지를 동기화하고 클린 페이지를 즉시 프리 리스트로 페이지를 옮긴다.

#### 버퍼 풀 상태 백업 및 복구
- InnoDB 서버의 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결돼 있다.
- 디스크의 데이터가 버퍼 풀에 데이터가 적재돼 있는 상태를 워밍업(Warming Up)이라고 표현하고, 버퍼 풀이 잘 워밍업된 상태는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보인다.
  - 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있다.
- MySQL 5.6 버전부터 `버퍼 풀 덤프 및 적재 기능`이 도입됐다.
- InnoDB의 버퍼 풀 상태를 백업할 수 있고, 서버를 다시 시작하면 백업된 버퍼 풀의 상태를 다시 복구할 수 있다.
  
#### 버퍼 풀의 적재 내용 확인
- InnoDB 버퍼 풀이 큰 경우에는 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 많이 느려지는 문제가 있었다.
- MySQL 8.0 부터는 테이블의 인덱스별로 데이터 페이지가 얼마나 버퍼 풀에 적재돼 있는지 확인할 수 있게 되었다.

<br>

### 4.2.8 Double Write Buffer

- 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다.
  - 이로 인해 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구를 할 수 없을 수도 있다.
  - 이렇게 페이지 일부만 기록되는 파셜 페이지 또는 톤 페이지 현상을 막기 위해 InnoDB에서는 Double-Write 기법을 이용한다.
- Double-Write 기법
  - 더티 페이지를 디스크로 플러시하기 전에 더티 페이지들을 묶어 한 번의 디스크 쓰기로 `시스템 테이블스페이스`의 `DoubleWrite 버퍼`에 기록한다.
  - 비정상적인 종료로 InnoDB가 재시작될 때 DoubleWrite 버퍼와 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 데이터 파일의 페이지로 복사한다.

<br>

### 4.2.9 언두 로그

> InnoDB는 트랜젝션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전의 데이터를 별도로 백업하며, 이 백업된 데이터를 언두 로그라고 한다.

- 언두 로그 모니터링
  - 언두 로그의 데이터는 크게 두 가지 용도로 사용된다.
    1. 트랜잭션의 롤백 대비용
    2. 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공
  - 트랜잭션의 유지시간에 따라 언두 로그의 양이 늘어날 수 있고, 이는 성능 문제로 이어질 수 있기 때문에 MySQL 서버 모니터링하는것이 좋다.
- 언두 테이블스페이스 관리
  - 언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다.
  - MySQL 8.0 이후로는 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선했다.

<br>

### 4.2.10 체인지 버퍼

> 버퍼 풀에 존재하지 않는, 보조 인덱스 페이지의 변경 내용을 캐시하는 데이터 구조

- RDBMS에서 레코드가 INSERT, UPDATE 될 때는 데이터 파일을 변경하는 작업뿐만 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.
  - 그런데 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하기 때문에 테이블에 인덱스가 많다면 많은 자원을 소모하게 된다.
- 그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 `체인지 버퍼`에 저장하고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킨다.
  - 사용자에게 결과를 전달하기 전에 중복 여부를 체크하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
  - 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 `체인지 버퍼 머지 스레드`라고 한다.
- 체인지 버퍼는 기본적으로 InnoDB 버퍼풀로 설정된 메모리 공간의 25%가지 사용할 수 있게 설정되어 있고, 필요하다면 50%까지 가능하다.

<br>

### 4.2.11 리두 로그 및 로그 버퍼

- 리두 로그는 트랜잭션의 4가지 요소인 ACID중에 `Durable`에 해당하는 영속성과 가장 밀접하게 연관돼 있다.
  - 리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안정장치다.
- 데이터베이스는 ACID도 중요하지만 성능도 중요하기 때문에 InnoDB 버퍼 풀(데이터 파일과 리두 로그 버퍼링)과 로그 버퍼(리두 로그 버퍼링)와 같은 자료 구조를 가지고 있다.
- MySQL 8.0 버전부터 InnoDB 리두 로그를 아카이빙할 수 있는 기능이 추가되었다.
  - 데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해준다.
- InnoDB의 리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화 되어 있다.
  - 트랜잭션이 커밋돼도 데이터 파일은 즉시 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.
  - MySQL 8.0 버전부터 리두 로그를 수동으로 활성화하거나 비활성화할 수 있게 되었다.
    - 데이터를 복구하거나 대용량 데이터를 적재하는 경우, 리두 로그를 비활성화해서 데이터의 적재 시간을 단축시킬 수 있다.

<br>

### 4.2.12 어댑티브 해시 인덱스

> 일반적으로 `인덱스`라고 하면 테이블에 사용자가 생성해둔 `B-Tree` 인덱스를 의미한다.

- `어댑티브 해시 인덱스`는 사용자가 수동으로 생성하는 인덱스가 아닌, InnoDB 에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.
- 기존 `B-Tree`의 문제점
  - `B-Tree` 인덱스에서 특정 값을 찾기 위해서는 루트 노드, 브랜치 노드, 리프 노트까지 거쳐야 원하는 레코드를 읽을 수 있다.
  - 이런 작업을 동시에 몇천 개의 스레드로 실행하면 CPU는 엄청난 프로세스 스케줄링을 하게 되고 자연히 쿼리의 성능은 떨어진다.
- 어댑티브 해시 인덱스는 이러한 B-Tree의 검색 시간을 줄여주기 위해 도입된 기능이다.
  - InnoDB는 자주 읽히는 데이터 페이지의 키 값을 이용해서 `해시 인덱스`를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 페이지를 즉시 찾아갈 수 있다.
  - `B-Tree`를 루트부터 리프 노드까지 찾아가는 비용이 없어지고, CPU는 적은 일을 하지만 쿼리의 성능은 빨라진다.
- 해시 인덱스는 `인덱스 키 값`과 `데이터 페이지 주소`의 쌍으로 관리된다.
  - key: `B-Tree 인덱스 고유 번호`와 `B-Tree 인덱스 실제 키 값` 조합으로 생성된 고유 인덱스 키
  - data : InnoDB 버퍼 풀에 로딩된 데이터 페이지 메모리 주소
- 어댑티브 해시 인덱스의 키 값에 `B-Tree 인덱스의 고유 번호`가 포함되는 이유는 InnoDB에서 어댑티브 해시 인덱스는 하나만 존재하기 때문이다.
  - 즉, 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되며, 특정 키 값이 어느 인덱스에 속한 것인지도 구분해야 하기 때문이다.

<br>

### 4.2.13 InoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 8.0으로 업그레이드되면서 MySQL 서버의 모든 시스템 테이블이 InnoDB 스토리지 엔진으로 교체되었다. 모든 기능을 InnoDB 스토리지 엔진만으로 구현할 수 있게 된 것이다.
- MyISAM은 도태되는 상황이며, 이후 버전에서는 없어질 것으로 예상한다.
- MEMORY 스토리지 엔진도 InnoDB에 비하면 동시 처리 능력이 떨어지고, 서버에서의 임시 테이블 사용에 있어서 장점이 없다. 향후 버전에서는 제거될 것으로 보인다.

<br>
<br>

## [4.3 MyISAM 스토리지 엔진 아키텍처](#목차)

<img width="300" src="https://github.com/user-attachments/assets/a8b94a16-0408-4ac4-ae19-c90e81e6c019">


### 4.3.1 키 캐시
- InnoDB의 버퍼 풀과 비슷한 역할을 하는 것이 MyISAM의 `키 캐시(키 버퍼)`다.
- MyISAM의 키 캐시는 인덱스만을 대상으로 작동하며, 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.

<br>

### 4.3.2 운영체제의 캐시 및 버퍼

- MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다.
- MyISAM 테이블의 데이터에 대해서는 디스크의 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능도 MyISAM 스토리지 엔진은 가지고 있지 않다. 
  - 그래서 읽기 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청될 수 밖에 없다.
- 대부분의 운영체제에는 캐시나 버퍼링 메커니즘을 탑재하고 있지만, 운영체제의 캐시 기능은 InnoDB처럼 전문적이지는 못하다. 하지만 없는 것보다는 낫다.

<br>

### 4.3.3 데이터 파일과 프라이머리 키 ( 인덱스 ) 구조

- MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용된다.
  - 반면에 InnoDB 스토리지 엔진을 사용하는 테이블은 프라이머리 키에 의해서 클러스터링되어 저장된다.
- 즉, MyISAM 테이블에 레코드는 프라이머리 키 값과 무관하게 INSERT 되는 순서대로 데이터 파일에 저장된다.
- MyISAM 테이블에 저장되는 레코드는 모두 `ROWID`라는 물리적인 주솟값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다.
- MyISAM에서 ROWID는 가변 길이와 고정 길이의 두 가지 방법으로 저장될 수 있다.

<br>
<br>

## [4.4 MySQL 로그 파일](#목차)

> 로그 파일을 이용하면 서버의 깊은 내부 지식이 없어도 MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아서 해결할 수 있다.
> MySQL 서버에 문제가 생겼을 때는 다음에 설명하는 로그 파일들을 자세히 확인하는 습관을 들일 필요가 있다.

### 4.4.1 에러 로그 파일

- MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다.
- MySQL 설정 파일(my.cnf)에서 log_error라는 이름의 파라미터로 정의된 경로에 생성된다.
- MySQL 설정 파일에 별도 정의되지 않은 경우에는 데이터 디렉터리에 .err 확장자가 붙은 파일로 생성된다. 아래의 메시지들을 가장 자주 보게 될 것이다.
  1. MySQL 이 시작하는 과정과 관련된 정보성 및 에러 메시지
  2. 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
  3. 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
  4. 정상적으로 종료된 커넥션 메시지 (Aborted connection)
  5. InnoDB의 모니터링 또는 상태 조회 명령 (SHOW ENGINE INNODB STATUS 같은)의 결과 메시지
  6. MySQL 의 종료 메시지

<br>

### 4.4.2 제너럴 쿼리 로그 파일 ( 제너럴 로그 파일 , General log)

- 가끔 MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아서 컴토해 볼 때가 있다.
- 이때는 쿼리 로그를 활성화해서 쿼리를 `쿼리 로그 파일`로 기록하게 한 다음, 그 파일을 검토하면 된다.
  - 쿼리 로그 파일에는 시간 단위로 실행했던 쿼리의 내용이 모두 기록된다.
- `제너럴 쿼리 로그` 파일의 경로는 general_log_file 이라는 이름의 파라미터에 설정되어 있다.
  - 슬로우 쿼리 로그와 다르게 제네럴 쿼리 로그는 실행전에 MySQL이 쿼리 요청을 받으면 바로 기록하므로 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다.

<br>

### 4.4.3 슬로우 쿼리 로그

- MySQL 서버의 쿼리 튜닝은 크게 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝으로 나눌 수 있다.
- 전자의 경우에는 검토해야 할 대상 쿼리가 전부라서 모두 튜닝하면 되지만, 후자의 경우에는 어떤 쿼리가 문제의 쿼리인지 판단하기가 상당히 어렵다.
- 이런 경우에 어떤 쿼리가 문제가 되는지 판단하는 `슬로우 쿼리 로그`가 많은 도움이 된다.
- 슬로우 쿼리 로그 파일에는 long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다.
- 또한, 제너럴 쿼리 로그 파일과는 다르게 정상적으로 수행되었지만 느린 쿼리들만 기록이 된다.

<br>
<br>
