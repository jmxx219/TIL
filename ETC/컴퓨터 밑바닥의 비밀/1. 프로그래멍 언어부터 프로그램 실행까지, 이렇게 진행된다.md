## 1. 프로그래멍 언어부터 프로그램 실행까지, 이렇게 진행된다

### 목차
- [1.1 여러분이 프로그래밍 언어를 발명한다면?](#11-여러분이-프로그래밍-언어를-발명한다면)
- [1.2 컴파일러는 어떻게 작동하는 것일까?](#12-컴파일러는-어떻게-작동하는-것일까)
- [1.3 링커의 말할 수 없는 비밀](#13-링커의-말할-수-없는-비밀)
- [1.4 컴퓨터 과학에서 추상화가 중요한 이유](#14-컴퓨터-과학에서-추상화가-중요한-이유)

<br>

## [1.1 여러분이 프로그래밍 언어를 발명한다면?](#목차)

### 창세기: CPU 는 똑똑한 바보
- CPU는 매우 원시적이고 단순한 장치로, 데이터 이동과 간단한 연산만을 처리할 수 있다.
- 그러나 CPU는 매우 빠른 속도를 자랑하며, 인간이 간단한 연산에서 CPU를 따라잡을 수 없다.
- 최초의 프로그래머는 CPU와 의사소통을 위해 '새의 언어'를 사용하였고, 이를 위해 천공 카드를 이용해 0과 1로 구성된 명령어를 입력했다.

### 어셈블리어 등장
- CPU가 겨우 몇 가지 명령어만 실행할 수 있다는 것을 발견하고, 기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시켰다.
- 이렇게 어셈블리어가 탄생했고, 프로그래머는 인간이 이해할 수 있는 단어(add, sub, mov 등)로 코드를 작성할 수 있게 되었다.

### 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 어셈블리어는 여전히 저수준 언어로, 모든 세부 사항을 신경 써야 하며, 복잡한 문제도 단순한 명령어를 이용해 해결해야 한다.
- 인간은 추상적인 표현에 익숙하지만, CPU는 구체적인 명령어를 요구하기 때문에 추상적인 표현을 구체적인 구현으로 자동으로 변환할 수 있는 방법이 필요하다.

### 가득한 규칙: 고급 프로그래밍 언어의 시작
- CPU가 실행하는 명령어는 대부분 매우 단도직입적이다.
  - 이 명령어 중에는 구체적으로 특정 행동을 하는 것 외에도 특정 상황에 따라 어떤 명령어를 실행할지 결정해야 하는 선택(조건문)이 필요하다.
  - 또, 어떤 경우엔느 일정한 명령어를 계속 반복해야 한다.
  - 그리고 개별적인 세부 사항만 차이가 있을 뿐 반복은 같은데, 이런 차이를 매개변수라고 한다. 이를 별도로 분리하여 매개변수를 제외한 나머지 명령어를 하나로 묶으면서 함수가 탄생했다.
- 결국 프로그래머는 `조건문(if-else)`, `반복문(while)`, `함수(func)` 등의 규칙을 발견하고 이를 통해 더 효율적인 코드 작성을 가능하게 했다.

### <인셉션>과 재귀: 코드 본질
- `blablabla`는 문장, 조건문, 순환문, 함수 호출 등 다양한 구문을 포함할 수 있으며, 이들 중첩은 재귀와 비슷하다.
  - 하나의 꿈속에 또 다른 꿈이 있고 그 꿈속에 또 다른 꿈이 반복되는 영화 <인셉션(inception)〉 처럼
  - 그리고 단계가 또 다른 단계에 중첩되는 〈인셉션〉은 이렇게 간결한 문장 몇 개로 표현할 수 있다.
      ```
      if: i f expr statement else statement
      for: while expr statement
      statement: i f | for | statement
      ```
- 세상의 모든 코드는 아무리 복잡하더라도 결과적으로는 모두 구문으로 귀결된다. 이것이 가능한 이유는 매우 간단한데 모든 코드는 `구문(syntax)`에 기초하여 작성되기 때문이다.

### 컴퓨터가 재귀를 이해하도록 만들기
- 인간은 구문에 따라 코드를 작성할 수 있고, 이 코드는 문자열에 불과하다. 컴퓨터가 재귀 구문으로 표현된 문자열을 인식하게 해야 한다.
- 재귀 구문에 따라 작성된 코드를 트리(tree) 형태로 표현할 수 있다. 구문 트리(syntax tree)!

### 우수한 번역가: 컴파일러
- 컴퓨터는 프로그래밍 언어를 처리할 때, 구문 정의에 따라 트리 형태로 코드를 구성할 수 있다.
  - 이 트리의 리프 노드는 매우 간단한 기계 명령어로 번역될 수 있고, 이 번역 결과를 차례대로 부모 노드에 적용하며 올라가면 전체 트리가 구체적인 기계 명령어로 번역된다.
- 고급 프로그래밍 언어를 CPU가 이해할 수 있는 기계 명령어로 번역하는 프로그램임에 `컴파일러`라는 이름을 붙였다.
- 이렇게 고급 프로그래밍 언어(high-level programming language)라는 놀라운 발명이 탄생했고, 이 시점부터 프로그래머는 인간이 인식할 수 있는 언어를 사용하여 코드를 작성할 수 있게 되었다.
  - 이로 인해 프로그래머 효율성이 급증하고, 소프트웨어 산업이 번성하기 시작했다.

### 해석형 언어의 탄생
- 다양한 CPU는 각자 고유한 명령어 집합을 가지고 있어, 하나의 CPU에서 생성된 기계 명령어가 다른 CPU에서는 실행되지 않는다.
  - 직접 표준 명령어 집합을 정의해서 CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성한다면 사용할 수 있다.
  - 따라서 CPU마다 상응하는 시뮬레이션 프로그램(`가상 머신`)이 있다면 여러 플랫폼에서 동일한 코드가 실행될 수 있다.
- 가상 머신은 `인터프리터`라는 이름으로 실행 코드를 해석하여, CPU 명령어로 변환하고 실행할 수 있게 되었다.
  - 이 아이디어를 바탕으로 C/C++, 자바, 파이썬 등 프로그래밍 언어가 만들어졌다.
  - 컴파일러는 언어 구문에 따라 코드 구문을 분석하여 구문 트리로 만들고, 이 구문 트리를 C/C++ 언어처럼 기계 명령어로 번역하여 CPU로 직접 넘기거나 자바처럼 바이트 코드(byte code)로 변환한 후 가상 머신으로 넘겨 실행한다.
- 고급 프로그래밍 언어는 추상적 표현이 뛰어나지만, 저수준 계층에 대한 제어 능력은 떨어지므로 운영 체제의 일부는 어셈블리어로 작성된다.

<br>

## [1.2 컴파일러는 어떻게 작동하는 것일까?](#목차)

### 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다
- 컴파일러는 고수준 언어를 저수준 언어로 번역하는 프로그램이며, 소스 파일을 받아들여 이를 실행할 수 있는 기계 명령어로 변환하여 실행 파일 형태로 만든다.

### 각각의 토큰 추출하기
- 컴파일러는 소스 코드에서 각각의 항목을 잘게 쪼개어 각 항목이 가지는 그 자체의 의미와 추가 정보를 결합하여 `토큰`으로 만든다.
- 이렇게 소스 코드에서 토큰을 추출하는 과정을 어휘 분석(exical analysis) 이라고 한다.

### 토큰이 표현하고자 하는 의미
- 컴파일러는 구문 규칙에 따라 토큰을 해석한 후, 이를 구문 트리로 표현하며 이 트리를 생성하는 전체 과정을 `구문 분석`이라고 한다.
- 구문 분석을 통해 코드가 올바르게 구성되었는지 확인하며, 문법 오류가 있을 경우 컴파일러는 이를 감지하여 오류를 보고한다.

### 생성된 구문 트리에 이상은 없을까?
- 컴파일러는 구문 트리가 의미적으로 올바른지 확인하는 `의미 분석`을 진행하고, 이 과정에서 오류가 발견되면 컴파일 오류를 발생시킨다.

### 구문 트리를 기반으로 중간 코드 생성하기
- 의미 분석이 끝나면 컴파일러는 구문 트리를 탐색한 결과를 바탕으로 좀 더 다듬어진 형태인 중간 코드(IR Code)를 생성한다.
- 때로는 중간 코드에 추가적인 최적화가 진행되기도 한다.

### 코드 생성
- 중간 코드는 어셈블리어 코드로 변환되어 최종적으로 기계 명령어로 번역되고, 이를 통해 CPU가 이해할 수 있는 `실행 파일`이 생성된다.
- 컴파일러는 소스 코드에서 시작해 최종 실행 파일을 만드는 과정에서 여러 단계를 거친다.
  - ex) GCC 컴파일러는 소스 코드 파일(code.c)을 컴파일하여 기계 명령어를 포함하는 대상 파일(code.o)을 생성한다.
  - 이때 모든 소스 파일에는 각각의 대상 파일(object file)이 있고, 이 대상 파일을 병합하는 `링크` 과정을 거쳐 실행 파일을 생성한다.
    - 여기서 링크를 담당하는 프로그램을 `링커(linker)`라고 한다.

<br>

## [1.3 링커의 말할 수 없는 비밀](#목차)

### 링커는 이렇게 일한다
- `링커`는 컴파일러가 생성한 대상 파일 여러 개를 하나로 묶어 하나의 최종 실행 파일을 생성하는 프로그램이다.
- 링커는 소스 코드의 함수와 변수들이 다른 모듈에서 어떻게 연결되어야 하는지 확인한다. 그리고 각 모듈 간의 종속성을 해결하고, 이를 기반으로 실행 파일을 생성한다. 
- 이 과정에서 `심벌 해석(symbol resolution)`과 `재배치(relocation)`가 이루어진다.
  - 심벌 해석: 참고하고 있는 외부 심벌에 대한 실제 구현이 어느 모듈이든지 단 하나만 있어야 하고, 링커는 이를 찾아내 확인하는 작업을 한다.
  - 재배치: 소스 파일을 컴파일 하는 시점에는 코드에서 참조하는 위치를 모든다. 따라서 이를 모아 나중에 실행 파일을 생성하는 과정에서 실제 메모리 주소로 변경하는 작업을 한다.

### 심벌 해석: 수요와 공급
- 이 단계에서 링커는 대상 파일에서 참조하고 있는 각각의 모든 외부 심벌마다 대상 정의가 반드시 존재하는지, 단 하나만 존재하는지 확인한다.
- 링커는 각 대상 파일에서 정의된 심벌과 외부에서 참조된 심벌을 비교하여 참조를 해결한다.
  - 심벌은 전역 변수와 함수의 이름을 포함하는 모든 변수 이름을 의미한다.
    - 지역 변수는 모듈 내에서만 사용되거 외부 모듈에서 참조할 수 없기 때문에 링커의 관심 대상이 아니다.
  - 링커가 관심을 두는 심벌에 대한 정보는 컴파일러가 생성하는 대상 파일로 부터 얻을 수 있다.
    - 대상 파일은 크게 `코드 영역`과 `데이터 영역`, `심벌 테이블`을 포함하고 있다.
      - 코드 영역: 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분
      - 데이터 영역: 소스 파일의 전역 변수가 저장되는 부분
      - 심벌 테이블: 내가 사용하는 외부 심벌과 내가 정의한 심벌(다른 모듈에서 사용할 수 있는 심벌) 두 가지 내용만 표현
- 링커는 공급이 수요를 충족하는지 확인해야 하며, 심벌 해석은 각 대상 파일에서 사용할 외부 심벌이 심벌 테이블에서 유일한 정의(unique definition)를 발견 가능한지 확인하는 작업이다.
  - 실제 코드를 작성할 때는 공급이 수요를 초과할 수 있다. 
  - 반대로 수요가 공급을 초과하는 상황은 발생해서는 안된다. 심벌에 대한 참고가 없다는 오류가 발생할 수 있다.

### 정적 라이브러리, 동적 라이브러리, 실행 파일

#### 정적 라이브러리
<img height="250" src="https://github.com/user-attachments/assets/4f7a5985-943e-4206-b4db-ac16db3034a9"> <img height="250" src="https://github.com/user-attachments/assets/5551672e-531b-417e-8576-358316fdf83a">

- 정적 라이브러리는 미리 컴파일된 함수들을 하나의 파일로 묶은 형태이다. 소스 파일을 미리 개별적으로 컴파일한 후, 실행 파일을 만들 때 이 정적 라이브러리를 링크하여 복사한다.
  - 코드가 의존하는 외부 코드를 다시 컴파일하지 않아도 되기 때문에 컴파일 속도가 빨라진다. 이를 `정적 링크`라고 한다.
  - 정적 링크는 대상 파일을 한데 모아 각의 대상 파일에서 데이터 영역과 코드 영역을 각각 결합하는 것으로 이핼할 수 있다.
- 모든 함수가 실행 파일에 복사되어 실행 파일의 크기가 커질 수 있으며, 라이브러리 코드가 변경될 때마다 해당 코드에 의존하는 프로그램도 다시 컴파일해야 한다.

#### 동적 라이브러리
- 동적 라이브러리는 실행 중에 프로그램에 로드되어 사용되는 라이브러리이다. 정적 라이브러리와 사용 방식과 사용 시간만 다르다.
- 실행 파일의 크기가 작아지고, 메모리 공간을 절약할 수 있다.
  - 동적 라이브러리를 사용하면 정적 라이브러리가 실행 파일에 라이브러리 내용을 모두 복사했던 것과 달리, 참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함된다.
  - 이 필수 정보는 `동적 링크`가 일어날 때 사용된다. 
- 동적링크 두 가지 방식
  1. 적재 동적 링크: 프로그램이 메모리에 적재될 때 동적 라이브러리가 링크되는 과정이다.
     - 실행 파일이 메모리로 로드되면, 적재 도구가 해당 파일의 동적 라이브러리 의존성을 확인하고, 필요한 라이브러리와 심벌의 위치를 찾아 동적 링커가 링크를 완료한다. 
     - 이 과정이 정상적으로 끝나면 프로그램이 실행되며, 문제가 발생하면 라이브러리를 찾을 수 없다는 오류가 발생한다.
  2. 실행 시간 동적 링크: 프로그램 실행 중 필요한 동적 라이브러리를 직접 로드하여 링크하는 방식이다.
     - 이 방식에서는 실행 파일 생성 시 동적 라이브러리 정보가 포함되지 않으며, 프로그래머가 코드에서 특정 API를 사용해 필요할 때 동적 라이브러리를 적재한다.

### 동적 라이브러리의 장단점

#### 장점
- 디스크 및 메모리 절약: 동적 라이브러리는 여러 프로그램에서 공유되므로, 디스크와 메모리에서 중복을 줄일 수 있다. 동일한 코드와 데이터가 여러 번 저장되지 않으며, 메모리에서 여러 프로세스가 라이브러리를 공유한다.
- 업그레이드 및 버그 수정 용이: 라이브러리 코드가 수정되면 동적 라이브러리만 다시 컴파일하고 교체하면 된다. 실행 파일을 다시 컴파일할 필요 없이 최신 버전의 라이브러리를 사용한다.
- 프로그램 기능 확장: 동적 링크는 플러그인 방식으로 프로그램 기능을 확장할 수 있어, 새로운 기능을 추가할 때 매우 유용하다.
- 언어 혼합 개발: C/C++와 같은 고성능 언어와 파이썬 등 높은 개발 속도를 요구하는 언어를 결합하여 성능을 최적화할 수 있다. C/C++로 작성된 핵심 부분을 동적 라이브러리로 컴파일하여 파이썬에서 호출하는 방식으로 사용할 수 있다.

#### 단점
- 성능 손실: 동적 링크는 프로그램이 적재 되는 시간 또는 실행 시점에 링크되기 때문에 정적 링크보다 성능이 약간 떨어질 수 있다.
- 주소 독립성:
  - 동적 라이브러리는 위치 독립 코드로 설계되어, 라이브러리의 코드가 특정한 메모리 주소에 고정되지 않고 어느 위치에 로드되더라도 정상적으로 작동한다.
    - 여러 프로세스가 이 라이브러리를 공유할 수 있기 때문에, 각 프로세스는 자신만의 메모리 공간을 가지며, 라이브러리의 함수가 어디에 위치할지는 고정되지 않는다.
  - 그래서 동적 라이브러리에서는 간접적인 주소 접근을 사용하여, 함수가 어디에 있든지 정확한 메모리 주소를 찾을 수 있도록 하는데 성능 손실이 발생할 수 있다.
  - 하지만 사용할 때 얻는 이점이 더 큰 가치가 있다.
- 종속성 문제: 동적 라이브러리에 의존하는 프로그램은 해당 라이브러리가 없거나 버전이 맞지 않으면 실행되지 않는다. 이로 인해 프로그램 배포 및 설치 시 어려움이 있을 수 있다.

### 재배치: 심벌의 실행 시 주소 결정하기
- 링커가 실행 파일을 생성할 때, 프로그램이 실행되는 시점에 함수가 적재될 메모리 주소를 확정해야 한다.
  - 하지만 컴파일러는 주소를 알 수 없으므로 임시로 0x00과 같은 값을 사용하여 호출 명령어를 작성한다.
  - 그리고 컴파일러는 변수나 함수의 메모리 주소를 알 수 없다는 사실을 `.relo.text`, `.relo.data`와 같은 정보를 대상 파일에 저장한다.
- 링커는 대상 파일에서 함수나 변수와 관련된 심벌을 해석하고, 참조된 심벌이 실제로 정의된 위치를 찾는다. 이 과정에서 링커는 함수나 변수의 실제 메모리 주소를 결정할 수 있게 된다.
- 링커는 심벌 해석을 통해 확정된 메모리 주소를 바탕으로 대상 파일에서 call 명령어와 같은 기계 명령어를 수정한다. 이 작업을 재배치라고 한다.
  - 임시로 지정된 메모리 주소(예: 0x00)를 실제 주소(예: 0x4004d6)로 변경한다. 이를 통해 실행 파일이 최종적으로 정확한 메모리 주소를 참조하도록 만든다.
- 링커가 실행 시간에 메모리 주소를 미리 알 수 있는 이유는 현대 운영 체제의 `가상 메모리 시스템` 덕분이다.

### 가상 메모리와 프로그램 메모리 구조

#### 프로그램 실행 시 메모리 구조
- 프로그램이 실행되면 프로그램의 프로세스가 메모리에 적재되고, 이 메모리는 여러 영역으로 나누어진다.
  - 스택 영역: 메모리의 상위 주소에 존재하고, 함수 실행 시 정보를 저장하는 곳이다.
  - 힙 영역: 동적 메모리 할당을 위한 공간으로, malloc과 같은 함수로 메모리를 할당한다.
  - 데이터 영역과 코드 영역: 실행 파일의 내용이 메모리에 적재되는 곳이다.
- 모든 프로그램은 실행된 후 코드 영역이 예외 없이 메모리 주소 `0x400000`에서 시작한다.
  - 두 프로그램 A와 B가 실행될 때, 코드 영역이 0x400000에서 시작할 때 메모리 주소 0x400000은 프로그램 A와 B에서 각각 다른 코드로 연결된다.
  - 이는 가상 메모리 덕분에 가능하다. 

#### 가상메모리
- 가상 메모리는 각 프로그램이 실행될 때 자기 자신만 모든 메모리를 독점적으로 사용한다고 착각하게 만든다. 
  - 실제 물리 메모리의 형상이 아닌 논리로만 존재하는 허상일 뿐이다.
- 프로그램은 표준적인 가상 메모리 구조를 사용하여 동일한 메모리 구조 가진다. 
  - 링커가 실행 파일을 생성하자마자 실행 시 심벌의 메모리 주소를 결정할 수 있는 것도 프로그램 실행 여부와 관계없이 프로세스 메모리 구조를 알고 있기 때문이다.
- 가상 메모리 주소는 `페이지 테이블`을 통해 물리 메모리 주소로 매핑되며, 각 프로세스는 자신만의 페이지 테이블을 가진다.
  - CPU가 메모리 주소에 접근하면, 하드웨어가 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환한다.

#### 가상 메모리 기본 원리

<img height="350"  src="https://github.com/user-attachments/assets/9668bbe7-4bfa-4286-be50-e0e529f4bb24">

- 모든 프로세스는 크기가 동일한 표준화된 가상 메모리 구조를 사용하며, 프로세스마다 각 영역의 크기는 다를 수 있지만 배치 순서는 동일하다.
- 물리 메모리의 크기와 가상 메모리의 크기는 다를 수 있으며, 물리 메모리에는 힙, 스택 구분이 존재하지 않는다.
- 모든 프로세스는 자신만의 페이지 테이블을 가지고 있으며, 같은 가상 주소라도 각 프로세스의 페이지 테이블에 따라 다른 물리 메모리 주소로 변환됩니다.
  - 이런 이유로 CPU 는 동일한 가상 메모리 주소에서 서로 다른 내용을 가져올 수 있습니다.

<br>

## [1.4 컴퓨터 과학에서 추상화가 중요한 이유](#목차)

### 프로그래밍과 추상화
- 프로그래밍에서 추상화는 복잡도를 제어하는 중요한 도구로, 프로그래머는 내부 구현을 신경 쓰지 않고 추상화된 API에만 집중하여 효율적으로 작업할 수 있다. 
- 객체 지향 언어는 다형성, 추상 클래스 등을 통해 쉽게 추상화를 구현할 수 있으며, 이를 통해 프로그램의 확장성과 요구 사항 변화에 유연하게 대응할 수 있다.

### 시스템 설계와 추상화

- 시스템 설계는 기본적으로 추상화에 기반하여 구축된다.
  - CPU: 하드웨어는 트랜지스터로 구성되어 있지만, 명령어 집합을 통해 세부 사항을 보호한다. 프로그래머는 기계 명령어만 사용하여 작업을 지시하면 된다.
  - 입출력 장치: 파일로 추상화되어, 파일이 어떻게 저장되는지에 대한 세부 사항을 신경 쓸 필요 없이 파일을 사용할 수 있다.
  - 프로세스: 실행 중인 프로그램은 프로세스로 추상화된다. 이를 통해 프로그램은 CPU를 독점한다고 가정하며, 여러 프로세스가 동시에 실행될 수 있다.
  - 가상 메모리: 물리 메모리의 크기에 관계없이, 프로그래머는 프로그램이 일정한 크기의 메모리에 접근한다고 가정할 수 있다. 또한, mmap 기능을 사용하면 가상 메모리에서 파일을 쉽게 조작할 수 있다.
  - 네트워크 프로그래밍: 소켓으로 추상화되어, 네트워크 패킷이나 네트워크 카드가 데이터를 송수신하는 방식에 대해 신경 쓸 필요가 없다.
  - 프로세스 환경: 프로세스와 그 실행 환경은 컨테이너로 추상화되어, 개발 환경과 배포 환경의 차이를 신경 쓸 필요가 없다.
  - 가상 머신: 운영 체제와 응용 프로그램은 가상 머신으로 묶여 추상화되어, 프로그래머는 하드웨어나ㄴ 운영 체제를 직접 설정하고 관리할 필요 없이 가상 머신만 관리하면 된다. 이는 클라우드 컴퓨팅 기술로 이어진다.
- 추상화는 프로그래머가 저수준 계층에서 점점 멀어지게 하며, 프로그래밍의 문턱을 낮춰 많은 사람들이 간단한 학습만으로 프로그램을 작성할 수 있도록 만든다.
- 각 추상화 계층은 편리한 작업 환경을 제공하지만, 만약 더 깊은 이해나 커스터마이징을 원한다면 저수준 계층에 대한 이해가 필수적이다.
