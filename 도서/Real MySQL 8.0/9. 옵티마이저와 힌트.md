# 9. 옵티마이저와 힌트


### 목차

- [9.1 개요](#91-개요)
- [9.2 기본 데이터 처리](#92-기본-데이터-처리)
- [9.3 고급 최적화](#93-고급-최적화)
- [9.4 쿼리 힌트](#94-쿼리-힌트)


<br>

> MySQL 서버로 요정된 쿼리는 결과는 동일하지만, 내부적으로 어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 한다. MySQL에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다. `옵티마이저`가 이러한 기능을 담당한다.

## [9.1 개요](#목차)

> 실행 계획을 이해하는 것은 상당히 어려운 부분이다. 하지만 실행 계획을 이해할 수 있어야만 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.

### 9.1.1 쿼리 실행 절차

- MySQL 서버에서 쿼리가 실행되는 과정은 크게 3단계로 나눌 수 있다.

1. `SQL 파싱(Parsing)` : 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
   - MySQL 서버의 `SQL 파서`라는 모듈로 처리한다.
   - MySOL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.
2. `최적화 및 실행 계획 수립` : SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - MySQL 서버의 `옵티마이저`에서 처리한다.
   - 이 단계가 완료되면 `실행 계획`이 만들어진다.
3. 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.
   - MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.

<br>

### 9.1.2 옵티마이저의 종류

> 옵티마이저는 현재 대부분의 DBMS가 선택하는 비용 기반 최적화 방법과 예전 초기 버전의 오라클 DBMS에서 많이 사용했던 규칙 기반 최적화 방법으로 크게 나눌 수 있다.

1. `규칙 기반 최적화 방법(Rule-based optimizer, RBO)`
   - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
   - 통계 정보를 조사하기 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 낸다.
2. `비용 기반 최적화(Cost-based optimizer, CBO)`
   - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
   - 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.

<br>
<br>

## [9.2 기본 데이터 처리](#목차)

> RDBMS들은 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다. 하지만 그 결과를 만들어 내는 과정은 천차만별이다.


### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다. 
  - MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
    - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 `리드 어헤드(Read ahead)` 작업이 자동으로 시작된다.
  - 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만, 특정 시점부터는 백그라운드 스레드로 작업을 넘겨 한 번에 읽는 페이지 수를 계속 증가시킨다.
  - 이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해두고, 포그라운드 스레드는 버퍼풀에 준비된 데이터를 가져다 사용하여 쿼리가 상당히 빨리 처리된다.

> 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미

<br>

### 9.2.2 병렬 처리

> MySQL 8.0 버전부터는 용도가 제한되어있지만 병렬 처리가 가능해졌다. 여기서 병렬처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미한다.

- `innodb_parallel_read_threads`라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다.
- 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

<br>

### 9.2.3 ORDER BY 처리(Using filesort)

> 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 `Files Sort` 라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

|         | 장점                                                                                                     | 단점                                                                                                                                                 |
|---------|--------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| 인덱스  | - 이미 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.                                                                   | - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. <br> - 인덱스 때문에 디스크 공간이 더 많이 필요하다. <br> - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다. |
| Filesort | - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. <br> - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                                                                                            |

- 다음의 이유로 모든 정렬에 인덱스를 사용할 수 없다.
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
  - 랜덤하게 결과 레코드를 가져와야 하는 경우

<br>

#### 소트 버퍼(Sort buffer)
- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 `소트 버퍼`라고 한다.
  - 정렬이 필요한 경우에만 할당되며, 쿼리의 실행이 완료되면 즉시 반납된다.
- 정렬할 레코드 수가 소트 버퍼 크기 내에 있으면 메모리에서 빠르게 정렬이 처리된다.
- 하지만 정렬해야 할 레코드가 소트 버퍼를 초과하면, 디스크에 임시 저장하면서 여러 번의 디스크 읽기/쓰기가 발생해 쿼리 속도가 느려진다.
- 또한 소트 버퍼는 글로벌 메모리영역이 아닌 세션 메모리 영역에 해당하므로, 커넥션 또는 정렬 작업이 많을수록 소트 버퍼가 소비하는 메모리 공간이 커진다.

<br>

#### 정렬 알고리즘
1. 싱글 패스 정렬 방식
   - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.
   - 투 패스 정렬 방식보다 더 많은 소트 버퍼 공간이 필요하다.
   - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보인다.
2. 투 패스 정렬 방식
   - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식이다.
   - 테이블을 두 번 읽어야 하기 때문에 상당히 불합리하다.
   - 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.
- 일반적으로 싱글 패스 정렬 방식을 사용하지만, 특정 조건에서는 투 패스 정렬 방식도 사용한다.

<br>

####  정렬 처리 방법

- 쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리되고, 일반적으로 아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어진다.
- 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있는지 검토하고, 이용할 수 없다면 HERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(`Filesort`)한다.
 
1. 인덱스를 이용한 정렬
   - 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 
   - 또한 WHERE절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
   - B-Tree 계열의 인덱스가 아닌 해시 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.
2. 조인의 드라이빙 테이블만 정렬
   - 일반적으로 조인이 수행되면 결과 레코드의 건수가 몇배로 불어나고, 레코드 하나하나의 크기도 늘어 난다. 
   - 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이 될 것이다.
   - 이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블의 칼럼만으로 ORDER BY 절을 작성해야 한다.
3. 임시 테이블을 이용한 정렬
   - 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 
   - 앞에서의 드라이빙 테이블을 이용한 방식 외에는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.
   - 3가지 정렬 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.


<br>

#### 정렬 처리 방법의 성능 비교

- 일반적으로 LIMIT는 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다. 하지만 ORDER BY나 GROUP BY 같은 작업은 모든 레코드에 대한 처리를 해야만 LIMIT으로 제한할 수 있기 때문에 쿼리가 느려진다.
- 쿼리가 처리 되는 방법은 2가지 방식으로 구분된다.
  1. 스트리밍 방식
     - 쿼리의 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라인트로 전송해주는 방식을 의미한다.
     - MySOL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.
  2. 버퍼링 방식
     - ORDER BY나 GROUP BY는 쿼리의 결과가 스트링되는 것을 불가능하게 한다. 
       - 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 하기 때문이다.
     - MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다.
- 인덱스를 이용한 정렬 방식만 스트리밍 형태의 처리이며, 나버지는 모두 버퍼링된 후에 정렬된다.
- 어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만든다. 
  - 가능하다면 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다.

<br>

#### 정렬 관련 상태 변수
- MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다. 
- 정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼간의 병합 적업은 몇 번이나 발생했는지 등을 확인할 수 있다.

<br>

### 9.2.4 GROUP BY 처리
> GROUP BY는 ORDER BY와 같이 쿼리를 스트리밍 방식으로 처리할 수 없다. GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용할 수 있고, GROUP BY 결과에 대해 필터링 역할을 수행한다.

> GROUP BY 작업은 인덱스를 이용할 때는 `인덱스 스캔(인덱스를 차례대로 읽는 방법)`과 `루스 인덱스 스캔(인덱스를 건너뛰면서 읽는 방법)`을 사용하고, 인덱스를 사용하지 못하는 쿼리에서는 `임시 테이블`을 사용한다.

#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때, GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- 그룹 함수 등의 그룹값을 처리하는 경우에는 임시 테이블이 필요할 때도 있다.

#### 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져온다.
- 옵티마이저가 루스 인덱스 스캔을 사용할 때는 실행 계획의 Extra 칼럼에 `Using index for group-by` 코멘트가 표시된다.
- 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다. 또한 프리픽스 인덱스는 루스 인덱스 스캔을 사용할 수 없다.
- 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다. (분포도가 좋지 않은 인덱스일수록 더 빠른 결가를 만들어낸다)

#### 임시 테이블을 사용하는 GROUP BY
- 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.
- MySQL 8.0 이후 부터는 묵시적인 정렬은 더 이상 실행되지 않는다.
  - 묵시적인 정렬: GROUP BY는 있지만, ORDER BY 절이 없는 쿼리에 대해서는 기본적으로 그루핑되는 칼럼을 기준으로 정렬한다.

<br>

### 9.2.5 DISTINCT 처리
> 특정 칼럼의 유니크한 값만 조회하려면 SELECT 쿼리에 `DISTINCT`를 사용한다. 크게 집합 함수(Min, Max, count 등)와 함께 사용되는 경우와 그렇지 않은 경우 두 가지로 나뉠 수 있다.

#### SELECT DISTINCT ...
- 단순히 SELECT되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다.
- SELECT 하는 레코드(튜플)를 유니크하게 SELECT 하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.
- 특히 MySQL 8.0 버전부터는 GROUP BY를 수행하는 쿼리에 ORDER BY 절이 없으면 정렬을 사용하지 않기 때문에 다음의 두 쿼리는 내부적으로 같은 작업을 수행한다.
    ```sql
    mysql> SELECT DISTINCT emp_no FROM salaries;
    mysal> SELECT emp_no FROM salaries GROUP BY emp_no;
    ```

#### 집합 함수와 함께 사용된 DISTINCT
- count(), MIN(),MAX()와 같은 집합 함수 내에서 사용될 수 있는데, 이 경우에는 일반적으로 SELECT DISTINCT와 다른 형태로 해석된다. 
  - 집합 함수가 없는 SELECT 쿼리에서 DISTINCT는 조회하는 모든 칼럼의 조합이 유니크한 것들만 가져온다.
  - 하지만 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.

<br>

### 9.2.6 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.
- 일반적으로 MySQL 엔진이 사용하는 임시 테이블을 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.
- MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다. 또한 쿼리의 처리가 완료되면 자동으로 삭제된다.

#### 메모리 임시 테이블과 디스크 임시 테이블
- MySQL 8.0 버전부터는 메모리는 `TempTable`이라는 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 `InnoDB` 스토리지 엔진을 사용하도록 개선됐다.
- `TempTable`이 최대한 사용 가능한 메모리 공간의 크기(1GB)를 초과하는 경우 임시 테이블을 디스크로 기록하게 되는데, 이 때 2가지의 디스크 저장 방식 중 하나를 선택한다.
    1. MMAP 파일로 디스크에 기록(기본 값, InnoDB 테이블로 전환하는 것보다 오버헤드가 적다.)
    2. InnoDB 테이블로 기록

#### 임시 테이블이 필요한 쿼리(대표적으로 내부 임시 테이블을 생성하는 케이스)
- ORDER BY, GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY, GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DERIVED인 경우

#### 임시 테이블이 디스크에 생성되는 경우
- 기본적으로 메모리상에 만들어진다. 하지만 다음 조건을 만족하면 디스크 기반의 임시 테이블을 사용한다.
  - UNION, UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
  - GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
  - 메모리 임시 테이블의 크기가 시스템 변수 값보다 큰 경우


#### 임시 테이블 관련 상태 변수
- 임시 테이블이 디스크에 생성됐는지 메모리에 생성됐는지 확인하려면 MySQL 서버의 상태 변수(`SHOW SESSION STATUS LIKE ‘Created_tmp%’;`)를 이용한다.
  - `Created_tmp_disk_tables`: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값
  - `Created_tmp_tables`: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값

<br>
<br>

## [9.3 고급 최적화](#목차)

> MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립하게 된다. 옵티마이저 옵션은 크게 `조인 관련된 옵티마이저 옵션`과 `옵티마이저 스위치`로 구분할 수 있다.

### 9.3.1 옵티마이저 스위치 옵션

> 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어하는데, `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용한다. 각각의 옵티마이저 스위치 옵션은 `default` 와 `on`, `of` 중에서 하나를 설정할 수 있다.

#### 1. MRR(Multi-Range Read)과 배치 키 액세스(mrr & batched_key_access)

- 네스티드 루프 조인 (Nested Loop Join)
  - MySOL 서버에서 지금까지 지원하던 조인 방식으로, 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행하는 방식이다.
  - 조인 처리는 MySQL 엔진이 담당하고, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다. 이 방식에서 스토리지 엔진은 아무런 최적화를 수행할 수 없다.
- MRR(Muli-Range Read) 방식
  - 네스티드 루프 조인의 단점을 보완하기 위해 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링한다.
  - 조인 버퍼에 레코드가 가득 차면 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다. 이렇게 함으로써 디스크의 데이터 페이지 읽기를 최소화할 수 있다.
- BKA(Batched Key Access) 조인
  - MRR을 응용해서 실행되는 조인 방식이다.
  - 부가적인 정렬 작업이 필요해서 오히려 성능에 안 좋은 영향을 미치기 때문에 기본적으로 비활성화되어 있다.

#### 2. 블록 네스티드 루프 조인(block_nested_loop)
- MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인(Nested Loop Join)이다.
  - 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.
  - 코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아서 반환한다.
- `네스티드 루프 조인`과 `블록 네스티드 루프 조인`의 가장 큰 차이
  1. **조인 버퍼**가 사용되는지 여부
     - 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다.
       - 즉, 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽는다.
     - 그래서 옵티마이저는 드리븐 테이블의 검색이 인덱스를 최대한 활용하도록 실행 계획을 수립한다.
     - 하지만 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔이 불가피할 때, 옵티마이저는 드라이빙 테이블의 레코드를 메모리에 캐시하고, 이 캐시를 드리븐 테이블과 조인해서 처리한다.
       - 이때 사용되는 메모리의 캐시를 `조인 버퍼(Join buffer)`라고 한다.
  2. 조인에서 **드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인**되느냐
     - 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다.
     - 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
     - 일반적인 조인은 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인은 결과의 정렬 순서가 흐트러질 수 있다.

#### 3. 인덱스 컨디션 푸시다운(index_condition_pushdown)
```sql
Alter table employees add index ix_lastname_firstname (last_name, first_name);
select * from employees where last_name='Acton' and first_name like '%sal';
```
- 기존 문제점
  - WHERE 조건 중 일부는 인덱스를 사용해 필터링할 수 없었고, 테이블에서 데이터를 모두 읽은 후에야 조건을 검사해야 했다.
  - 위의 쿼리에서 `last_name='Acton'`은 인덱스 레인지 스캔을 사용할 수 있지만, `first_name LIKE '%sal'` 조건은 데이터를 모두 읽은 후 원하는 결과인지 비교해보는 체크 조건(필터링 조건)으로만 사용된다.
  - 이로 인해 불필요한 데이터 읽기와 성능 저하가 발생했다.
    - 인덱스를 비교하는 작업은 실제 InnoDB 스토리지 엔진이 수행하지만, 테이블의 레코드에서 first_name 조건을 비교하는 작업은 MySOL 엔진이 수행하는 작업이다.
    - MySQL 5.5버전 까지는 인덱스를 범위 제한 조건으로 사용하지 못하는 first_name 조건을 MySOL 엔진이 스토리지 엔진으로 아예 전달해주지 않았다. 
    - 그래서 스토리지 엔진은 불필요한 테이블의 읽기를 수행할 수 밖에 없었다.
- 인덱스 컨디션 푸시다운(ICPD) 작동 방식
  - MySOL 5.6 버전부터는 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 칼럼의 조건이 있다면, 스토리지 엔진으로 전달할 수 있게 개선됐다.
    - 인덱스에 포함된 칼럼 조건(`first_name LIKE '%sal'`)을 스토리지 엔진에 전달한다.
    - 스토리지 엔진은 인덱스를 사용해 추가 필터링을 수행한 후, 일치하는 레코드만 테이블에서 읽는다.
    - 결과적으로 불필요한 테이블 레코드 접근이 최소화된다.

#### 4. 인덱스 확장(use_index_extensions)
- InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션
  - InnoDB 스토리지 엔진은 프라이머리 키(dept_no, emp_no)를 클러스터링 키로 생성한다.
  - 모든 세컨더리 인덱스(from_date)는 리프 노드에 프라이머리 키 값을 가진다. 
  - (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동한다.
- 예전과 다르게 MySQL 서버가 업그레이드되면서 옵티마이저는 세컨더리 인덱스의 마지막에 프라이머리 칼럼이 숨어있다는 것을 인지하고 실행 계획을 수립하도록 개선됐다.
- 그뿐만 아니라, InnoDB의 프라이머리 키가 세컨더리 인덱스에 포함돼 있으므로 별도의 정렬 작업 없이 인덱스를 활용해서 정렬이 처리되는 장점도 있다.


#### 5. 인덱스 머지(index_merge)
- 인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다. 
- 하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.
  - 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
- 각각의 결과를 어떤 방식으로 병합할지에 따라 세가지 실행 계획으로 구분된다.

#### 6. 인덱스 머지 - 교집합(index_merge_intersection)
```sql
select * from employees where first_name='George' and emp_no between 10000 and 20000;
```
- 2개 이상의 where 조건을 가지고 있고, 모두 인덱스를 사용할 수 있을 때 두 키를 모두 사용해서 쿼리를 처리하는 방식이다. 
- 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합을 반환한다.
- 위의 쿼리에서 두 조건에 대한 인덱스가 모두 존재하고, 상대적으로 많은 레코드를 가져와서 처리해야 한다면 인덱스를 각각 검색해서 교집합 하는 방식이 더 효율적일 수 있다.

#### 7. 인덱스 머지 - 합집합 (index_merge_union)
```sql
select * from employees where first_name='Matt' or hire_date='2022-07-13';
```
- WHERE 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용되는 최적화다.
  - 여러 개의 인덱스를 각각 검색해서 그 결과의 합집합을 반환한다.
- 합집합의 경우 중복을 제거해주어야 한다.
  - 각각의 인덱스로 조회 시에 프라이머리 키를 기준으로 정렬이 되어있다. 
  - 따라서 두 집합에서 하나씩 가져와 서로 비교하면서 중복된 레코드들을 정렬 없이 걸러낸 수 있다.
  - 이때 사용되는 것이 `우선순위 큐 알고리즘`이다.

#### 8. 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
- Union 알고리즘은 중복을 제거하기 위해 정렬된 결과가 필요하지만, 별도의 정렬을 수행하지 않는다.
- 하지만 인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우, MysQL 서버는 `Sort union` 알고리즘을 사용한다.
  - 각 집합을 프라이머키 키 칼럼으로 정렬한 다음에 중복 제거를 수행한다.

#### 9. 세미 조인(semijoin)
- 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 `세미 조인`이라고 한다.
- 세미 조인 쿼리의 성능을 개선하기 위한 다음과 같은 최적화 전략이 있다.
  - Table Pull-out
  - First Match 
  - Loose Scan 
  - Materialization
  - Duplicate Weed-out
- 쿼리에 사용되는 테이블과 조인 조건의 특성에 따라 MySQL 옵티마이저는 사용 가능한 전략들을 선별적으로 사용한다.

#### 10. 테이블 풀-아웃(Table Pull-out)
- 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다.
  - 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법이었다.
- Table pullout 최적화를 사용할 수 있는 상황은 다음과 같다.
  - 세미 조인 서브쿼리에서만 사용 가능하다.
  - 서브쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.
- Table pullout 최적화의 특성
  - Table pullout이 적용된다고 하더라도 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것은 아니므로 MySQL에서는 가능하다면 Table pullout 최적화를 최대한 적용한다.
  - 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다.
  - MySQL에서는 `최대한 서브쿼리를 조인으로 풀어서 사용해라` 라는 튜닝 가이드가 많은데, Table pullout 최적화는 사실 이 가이드를 그대로 실행하는 것이다. 이제부터는 서브쿼리를 조인으로 풀어서 사용할 필요가 없다.

#### 11. 퍼스트 매치(firstmatch)
- First match 최적화 전략은 `IN(subquery)` 형태의 세미 조인을 `EXISTS(subquery)` 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
- MySOL 5.5에서 수행했던 최적화 방법인 `IN-t0-EXISTS` 변환과 거의 비슷한 처리 로직을 수행한다.
- FirstMatch 최적화의 몇 가지 제한 사항과 특성
  - 서브쿼리에서 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로(Short-cut path)이기 때문에 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
  - 실행 계획의 Extra 칼럼에는 `FirstMatch(table-N)` 문구가 표시된다.
  - 상관 서브쿼리(Correlated subquery)에서도 사용될 수 있다.
  - GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.

#### 12. 루스 스캔(loosescan)
- 세미 조인 서브쿼리 최적화의 LooseScan은 인덱스를 사용하는 GROUP BY 최적화 방법에서 살펴본 `Using index for group-by`의 루스 인덱스 스캔(Loose Index Scan)과 비슷한 읽기 방식을 사용한다.
- 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그다음으로 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다.
  - 그래서 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다.
- 루스 인덱스 스캔 최적화는 다음과 같은 형태의 서브쿼리들에서 사용할 수 있다.
    ```sql
    SELECT . . FROM . . WHERE expr IN (SELECT keypart1 FROM tab WHERE .)
    SELECT . . FROM .. WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1='상수' ...)
    ```

#### 13. 구체화(Materialization) 
- 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다. 
  - 여기서 구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미한다.
- Materialization 최적화는 다른 서브쿼리 최적화와는 달리, 서브쿼리 내에 GROUP BY절이 있어도 이 최적화 전략을 사용할 수 있다.
- Materialization 최적화의 몇 가지 제한 사항과 특성
  - `IN(subquery)`에서 서브쿼리는 `상관 서브쿼리(Correlated subquery)`가 아니어야 한다.
  - 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
  - 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.

#### 14. 중복 제거(Duplicated Weed-out)
- 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.
- Duplicate Weedout 최적화의 장점과 제약 사항
  - 서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있는 최적화다.
  - 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
  - Duplicate Weedout은 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

#### 15. 컨디션 팬아웃(condition_fanout_filter)
- 옵티마이저가 실행 계획을 수립할 때 최적의 인덱스를 선택하기 위해 사용하는 기능이다.
  - 실행 계획에서 filtered 칼럼은 값의 분포도를 의미하고, 이 분포도는 실행 계획을 선정하는 데 중요한 역할을 한다.
- condition_fanout_filter 최적화가 filtered 칼럼 값을 예측하는 방법
  - 다음과 같은 조건을 만족하는 칼럼의 조건들에 대해 조건을 만족하는 레코드의 비율을 계산할 수 있다.
    - WHERE 조건절에 사용된 칼럼에 인덱스가 있는 경우
    - WHERE 조건절에 사용된 칼럼에 히스토그램이 존재하는 경우

#### 16. 파생 테이블 머지(derived_merge)
- 예전 버전의 MySQL 서버에서는 FROM 절에서 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리했다. 
  - 내부적으로 생성되는 임시 테이블은 처음에는 메모리에 생성되지만, 임시 테이블에 저장될 레코드 건수가 많아지면 결국 디스크로 다시 기록돼야 한다.
  - 그래서 임시 테이블의 크기가 커지면 메모리가 아닌 디스크에 쓰여지게 되고 이로 인해 쿼리의 성능은 많이 느려진다.
- MySQL 5.7 부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입됐다. 
  - 여기서 `derived_merge` 최적화 옵션은 이러한 임시 테이블 최적화를 활성화할지 여부를 결정한다.

#### 17. 인비저블 인덱스 (use_invisible indexes)
```sql
-- // 옵티마이저가 ix_hiredate 인덱스를 사용하지 못하게 변경
mysql> ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE;
-- // 옵티마이저가 ix_hiredate 인덱스를 사용할 수 있게 변경
mysql> ALTER TABLE employees ALTER INDEX ix_hiredate VISIBLE;
```
- MySQL 8.0 부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐다. 
- 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어할 수 있다.

#### 18. 스킵 스캔(Skip_scan)
- 인덱스의 핵심은 값이 정렬돼 있는다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
- (A, B, C) 칼럼으로 구성된 인덱스가 있을 때, WHERE 절에 B와 C 칼럼에 대한 조건을 가지고 있다면 이 쿼리는 인덱스를 활용할 수 없다.
  ```sql
  mysal> ALTER TABLE employees ADD INDEX ix_gender_birthdate (gender, birth_date);
    
  -- // ix_gender_birthdate 인덱스를 사용하지 못하는 쿼리
  mysal> SELECT * FROM employees WHERE birth_date>=' 1965-02-01';
  -- // ix_gender_birthdate 인덱스를 사용할 수 있는 쿼리
  mysql> SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
  ```
  - employees 테이블에 다음과 같은 인덱스가 있다고 가정해보자.
  - 이 인덱스를 사용하기 위해서는 WHERE 조건절에 gender 칼럼에 대한 비교 조건이 필수적이다.
- MySQL 8.0 버전부터 도입된 인덱스 스킵 스캔은 제한적이긴 하지만 인덱스의 이런 제약 사항을 뛰어넘을 수 있는 최적화 기법이다. 
  - 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다.
  - 그런데 인덱스의 선행 칼럼이 매우 다양한 값을 가지는 경우에는 인덱스 스킵 스캔 최적화가 비효율적일 수 있다.
  - 따라서 MySQL 8.0 옵티마이저는 인덱스의 선행 칼럼이 소수의 유니크한 값을 가질 때만 인덱스 스킵 스캔 최적화를 사용한다.

<br>
<br>

## [9.4 쿼리 힌트](#목차)


<br>
<br>
